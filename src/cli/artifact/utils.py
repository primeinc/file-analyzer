#!/usr/bin/env python3
"""
Shared utility functions for artifact management.

This module provides utility functions used by multiple modules
in the artifact management package.
"""

import os
import json
import shutil
import datetime
from typing import List, Tuple

# Import artifact_guard utilities
from src.core.artifact_guard import ARTIFACTS_ROOT, ARTIFACT_TYPES

def check_artifact_sprawl(check_dir: str = ".") -> Tuple[bool, List[str]]:
    """
    Check for artifacts outside the standard structure.
    
    Args:
        check_dir: Directory to check
        
    Returns:
        Tuple[bool, List[str]]: (no_sprawl_found, sprawl_paths)
    """
    # Convert to absolute path
    check_dir = os.path.abspath(check_dir)
    
    # Find artifact directories outside canonical structure
    non_canonical_dirs = []
    project_root = os.path.abspath(os.path.join(os.path.dirname(ARTIFACTS_ROOT), ".."))
    root_artifacts_dir = os.path.join(project_root, "artifacts")
    
    # Skip project root artifacts dir if it's in .gitignore
    skip_root_artifacts = False
    gitignore_path = os.path.join(project_root, ".gitignore")
    if os.path.exists(gitignore_path):
        with open(gitignore_path, 'r') as f:
            if any(line.strip() == "/artifacts/" for line in f):
                skip_root_artifacts = True
    
    # Walk the directory tree to find artifacts/ directories
    for root, dirs, _ in os.walk(check_dir):
        # Skip the canonical ARTIFACTS_ROOT
        if root == os.path.dirname(ARTIFACTS_ROOT) and "artifacts" in dirs:
            continue
            
        # Check for artifacts/ directories
        if "artifacts" in dirs:
            artifacts_dir = os.path.join(root, "artifacts")
            # Skip the canonical path
            if artifacts_dir == ARTIFACTS_ROOT:
                continue
            # Skip the root project artifacts if it's properly gitignored
            if skip_root_artifacts and artifacts_dir == root_artifacts_dir:
                continue
            # Otherwise add to non-canonical list
            non_canonical_dirs.append(artifacts_dir)
    
    # Return results
    return len(non_canonical_dirs) == 0, non_canonical_dirs

def clean_tmp_artifacts():
    """
    Clean only the tmp directory.
    
    Returns:
        Tuple[bool, str]: (success, message)
    """
    tmp_dir = os.path.join(ARTIFACTS_ROOT, "tmp")
    
    try:
        # Remove all files in tmp directory
        if os.path.exists(tmp_dir):
            for item in os.listdir(tmp_dir):
                item_path = os.path.join(tmp_dir, item)
                if os.path.isdir(item_path):
                    shutil.rmtree(item_path)
                else:
                    os.unlink(item_path)
        
        # Recreate empty directory
        os.makedirs(tmp_dir, exist_ok=True)
        return True, "Temporary artifacts cleaned"
    except Exception as e:
        return False, f"Failed to clean temporary artifacts: {str(e)}"

def generate_env_file() -> Tuple[bool, str, str]:
    """
    Generate an artifacts.env file for sourcing in shell scripts.
    
    Returns:
        Tuple[bool, str, str]: (success, file_path, message)
    """
    env_file = os.path.join(os.path.dirname(ARTIFACTS_ROOT), "artifacts.env")
    
    try:
        # Create the file header
        with open(env_file, 'w') as f:
            f.write(f"# Artifact environment variables\n")
            f.write(f"# Source this file to get standard artifact paths\n")
            f.write(f"# Generated by 'fa artifact env-file' on {datetime.datetime.now()}\n\n")
            f.write(f"export ARTIFACTS_ROOT=\"{ARTIFACTS_ROOT}\"\n")
            
            # Add exports for each artifact type
            config_file = os.path.join(ARTIFACTS_ROOT, ".artifact-config.json")
            if os.path.exists(config_file):
                with open(config_file, 'r') as cf:
                    try:
                        config = json.load(cf)
                        structure = config.get("structure", {})
                        
                        for dir_name, description in structure.items():
                            var_name = f"ARTIFACTS_{dir_name.upper()}"
                            dir_path = os.path.join(ARTIFACTS_ROOT, dir_name)
                            f.write(f"export {var_name}=\"{dir_path}\" # {description}\n")
                    except json.JSONDecodeError:
                        # If config file is invalid, just add default directories
                        for dir_name in ARTIFACT_TYPES:
                            var_name = f"ARTIFACTS_{dir_name.upper()}"
                            dir_path = os.path.join(ARTIFACTS_ROOT, dir_name)
                            f.write(f"export {var_name}=\"{dir_path}\"\n")
            else:
                # No config file, just add default directories
                for dir_name in ARTIFACT_TYPES:
                    var_name = f"ARTIFACTS_{dir_name.upper()}"
                    dir_path = os.path.join(ARTIFACTS_ROOT, dir_name)
                    f.write(f"export {var_name}=\"{dir_path}\"\n")
            
            # Add helper functions
            f.write("""
# Helper function to get specific artifact directories
get_artifact_path() {
  local type="$1"
  local name="$2"
  
  case "$type" in
    analysis|vision|test|benchmark|json|tmp)
      dir_var="ARTIFACTS_${type^^}"
      dir_path="${!dir_var}/$name"
      mkdir -p "$dir_path"
      echo "$dir_path"
      ;;
    *)
      echo "Unknown artifact type: $type" >&2
      echo "Valid types: analysis, vision, test, benchmark, json, tmp" >&2
      return 1
      ;;
  esac
}

# Clean temporary artifacts
clean_tmp_artifacts() {
  rm -rf "$ARTIFACTS_TMP"/*
  mkdir -p "$ARTIFACTS_TMP"
}
""")
        
        return True, env_file, f"Generated environment file: {env_file}"
    except Exception as e:
        return False, "", f"Failed to generate environment file: {str(e)}"